# 设计模式

## 单例

>单例模式（Singleton），也叫单子模式，是一种常用的软件设计模式。在应用这个模式时，单例对象的类必须保证只有一个实例存在。许多时候整个系统只需要拥有一个的全局对象，这样有利于我们协调系统整体的行为。比如在某个服务器程序中，该服务器的配置信息存放在一个文件中，这些配置数据由一个单例对象统一读取，然后服务进程中的其他对象再通过这个单例对象获取这些配置信息。这种方式简化了在复杂环境下的配置管理。

### 使用场景

单机游戏中的主角，各种管理器（例如音量管理这种只需要一个的）

### 有什么用

例如在游戏中很多地方都要获取主角身上的组件或者脚本，每次获取都要使用Transform.Find()等方法来找到，使用单例之后可以直接通过类名来获取到主角对象上面对应的组件。

### 怎么用

GameManager脚本

```csharp
using System;
using UnityEngine;
using UnityEngine.UI;

public class GameManager : MonoBehaviour
{
    private static GameManager _ins;
    public static GameManager Ins { get { return _ins; } }
    private void Start()
    {
        if (!_ins)
        {
            _ins = this;
        }
    }
}

```

其他脚本：

```csharp
using System;
using UnityEngine;
using UnityEngine.UI;

public class Other : MonoBehaviour
{
    private void Update()
    {
      GameManager.Ins.value++;
      //Anythings
    }
}

```

## 对象池(Object Pool)

### 用途

>游戏中，我们常常会遇到频繁得创建和销毁大量相同对象的场景。如果我们不做任何的特殊处理，这种场景会出现两个性能问题——大量的内存碎片以及频繁的分配内存空间。而对象池能供完美得解决这两个问题。

### 原理

>当创建对象时，对象池将对象放入池管理的某种内存连续的数据结构中（数组或者栈等）。当不需要对象时，对象池并不销毁对象，而是将对象回收到池中，下次需要的时候再次从池中拿出来。
因为，对象储存在内存连续的数据结构中，所以解决了内存碎片的问题。
因为，对象每次用完以后就放回池中循环利用而不是再次创建和销毁，这样就解决了频繁的内存分配和销毁的问题。

>目前我游戏开发中遇到比较多的:
观察者模式(事件的收发，例如课程中主角死亡后怪物的欢呼动画)
装饰器模式(也就是开发中我们往物体上挂载组件来拓展物体功能，目前unity是有这一套的框架了，不过如果后续要优化的话可能就要自己写了)
其他还有一些像抽象工厂、模板模式等等因为自己理解不太够和在开发中遇到的不够就不细说了
