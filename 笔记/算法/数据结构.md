# 数据结构

## 数组

数组在内存中是连续存储的
连续存储优点是:

- 空间效率高
- 支持随机访问
- 缓存局部性: 当访问数组元素时，计算机不仅会加载它，还会缓存其周围的其他数据，从而借助高速缓存来提升后续操作的执行速度。

缺点:

- 插入和删除效率低
- 长度不可变
- 空间浪费:分配的空间超过了实际使用的空间 剩下的空间将会被浪费

### 数组其他应用

很多数据结构底层都是通过数组来实现的,数组可以用来实现队列 栈 哈希表等其他数据结构

## 链表

单向链表通常用于实现栈、队列、哈希表和图等数据结构。

- 栈与队列：当插入和删除操作都在链表的一端进行时，它表现出先进后出的的特性，对应栈；当插入操作在链表的一端进行，删除操作在链表的另一端进行，它表现出先进先出的特性，对应队列。
- 哈希表：链地址法是解决哈希冲突的主流方案之一，在该方案中，所有冲突的元素都会被放到一个链表中。
- 图：邻接表是表示图的一种常用方式，在其中，图的每个顶点都与一个链表相关联，链表中的每个元素都代表与该顶点相连的其他顶点。

双向链表常被用于需要快速查找前一个和下一个元素的场景。

- 高级数据结构：比如在红黑树、B 树中，我们需要访问节点的父节点，这可以通过在节点中保存一个指向父节点的引用来实现，类似于双向链表。
- 浏览器历史：在网页浏览器中，当用户点击前进或后退按钮时，浏览器需要知道用户访问过的前一个和后一个网页。双向链表的特性使得这种操作变得简单。
- LRU 算法：在缓存淘汰算法（LRU）中，我们需要快速找到最近最少使用的数据，以及支持快速地添加和删除节点。这时候使用双向链表就非常合适。

循环链表常被用于需要周期性操作的场景，比如操作系统的资源调度。

- 时间片轮转调度算法：在操作系统中，时间片轮转调度算法是一种常见的 CPU 调度算法，它需要对一组进程进行循环。每个进程被赋予一个时间片，当时间片用完时，CPU 将切换到下一个进程。这种循环的操作就可以通过循环链表来实现。
- 数据缓冲区：在某些数据缓冲区的实现中，也可能会使用到循环链表。比如在音频、视频播放器中，数据流可能会被分成多个缓冲块并放入一个循环链表，以便实现无缝播放。

## 列表list

列表本质上还是数组,也被叫做动态数组
相比较与数组,列表可以自由添加和删除元素
在列表尾部添加元素时间复杂度为O(1),但插入和删除效率和数组一致,都是O(n)

## 堆

c#中使用PriorityQueue来实现堆这种数据结构,堆是完全二叉树
堆分为两种 一种是小顶堆

```csharp
PriorityQueue<int, int> minHeap = new();
```

默认创建出的优先队列就是小顶堆
如果要创建大顶堆需要自定义比较器,来让顺序反过来

```csharp
PriorityQueue<int, int> minHeap=new PriorityQueue<int>(Comparer<int>.Create((x, y) => y - x));
```

> 是一个用于创建自定义比较器的方法，它指定了如何比较两个整数 x 和 y 以确定它们的顺序。这个比较器用于在创建 PriorityQueue 时定义元素之间的优先级关系。在这里，(x, y) => y - x 表示比较 y 和 x 的结果，即将 y 减去 x。这意味着，如果 y 大于 x，则比较结果将为正数，将 y 放在 x 前面，从而实现了最大堆。

### 常见应用

- 优先排序
  入队和出队时间复杂度都是O(logn),比较高效
- 堆排序
  一种排序方式,通过入队可以对一组数据进行排序
- 获取最大的n的元素
  